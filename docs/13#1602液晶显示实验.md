#  第13章 1602液晶显示实验

## 13.1 LCD1602液晶显示模块简介

![](../media/image136.png)  

图13-1 1602液晶显示模块

1602液晶显示模块是一种通用的工业液晶显示模块，专门用来显示字母、数字、符号等的点阵型液晶显示模块。从名字就可以看出该液晶显示模块有2行，每行16个字符，共可以显示32个字符。

每个字符是由5x7或者5x11的点阵位组成，我们这里讲解的为5x7模式的模块。模块显示界面结构尺寸如下图所示：

![](../media/image137.png)  

图13-2 LCD1602液晶显示模块

与数码管相比，不需周期性的对显示进行刷新，只需将字符按照时序要求发送给1602液晶显示模块便可一直显示，有效的节省了单片机的系统资源。

如上图左上角所示，1602模块共有16个引脚，包括了电源，数据，控制等引脚，单片机通过这些引脚来控制1602显示相关的内容，我们这一章详细讲解如何控制1602，并写好相应的底层驱动代码，在后续章节需要使用1602的时候，不需要再来学习它的工作原理，只需调用相应的函数即可，不必再重复造轮子。

表13-1 LCD1602引脚定义

![](../media/image138.png)  

第1，2引脚：VDD、VS S为1602供电的正负极，最佳供电电压为5V。

第3引脚：VL液晶显示偏压信号，即为显示屏的对比度调节端，当接电源时对比度最高，接地时对比度最低，在使用中往往接一个可变电阻来调节显示对比度。

第4引脚：RS为数据/命令选择端，当RS=1时，选择操作1602内部的数据寄存器，当RS=0时，选择操作内部指令寄存器。

第5引脚：R/W为读写选择端，当R/W=1时，对1602进行读数据操作，当R/W=0时，对1602进行写操作。

第6引脚：E为1602液晶显示模块使能端，与RS，R/W配合使用在高电平时读取信息，负跳变时执行指令。

第7~14引脚：为8位的双向数据端口D0~D7。

第15，16引脚：BLA背光源正极，BLK背光源负极。BLK接地，BLA接电源VDD时，1602液晶背光点亮，接GND时，背光熄灭。

Nebula Pi单片机开发板1602液晶显示模块的电路连接图如下图所示：

![](../media/image139.png)  

图13-3 LCD1602电路连接图

我们结合表13-1的引脚定义和图13-3的电路原理图来进行详细的分析。电路右侧的接插件H1为一个20个孔的排孔，如下图右上角所示，1602只用到了1-16孔，第17-20这里用不到，暂时不管他，只需把液晶模块插入到电路板上即可。

a.  在1602的引脚定义中，1、2分别为地和电源正，原理图中1接GND，2接VCC；

b.  3为液晶显示偏压信号，用来调节显示对比度的，原理图中3连接到了一个可变电阻R2，调节这个电阻R2可以调节显示对比度了，位置如下图右下所示；

c.  4，5，6分别为1602的控制信号，电路中连到了单片机的P36、P35、P34；

d.  7-14位液晶显示器的数据D0-D7引脚，电路中直接连接到了单片机的P2口；

e.  15，16分别为1602的液晶背光电源和地，电路图中直接连接到了VCC和GND。

**重点：**

**只需要控制单片机的引脚P36，P35，P34，P2口，便可以实现对1602的控制了。**

![](../media/image140.png)  

图13-4 LCD1602 PCB布局

## 13.2 1602读、写操作时序解析

如何操作1602，在它的数据文档中说的非常清楚，我们这里结合1602的数据文档，将他变成代码。

下面讲解如何读取或向1602写入一个字节。

### 13.2.1 单片机读取1602的一个字节

通过查找1602的数据手册，读、写时序如下图所示：

![](../media/image141.png)  

图13-5 读操作时序

读操作时序解析如下：

上图中，RS对应P36，R/W对应P35，E对应P34，DB0-DB7对应P2。

a.  将R/W拉高进入读操作模式，同时RS要么为高电平、要么为低电平，高电平时为读数据操作，低电平时为读状态操作；

b.  经过t~SP1~时间之后才可将使能信号E拉高，并且E的高电平维持时间为t~PW~，在使能信号E拉高之后不超过t~D~时间内，1602液晶显示器将数据放在DB0~DB7数据线上；

c.  这时我们将数据读取并将使能E拉低，整个数据或状态的读取就完成了。

编写读状态函数RD_sta()代码如下：
```c
sbit RS_1602 = P3^6; //1602，RS、R/W，E引脚定义
sbit RW_1602 = P3^5;
sbit EN_1602 = P3^4;
  
unsigned char RD_sta()//读状态函数
{
    unsigned char sta;
  
    RS_1602 = 0;
   RW_1602 = 1;//进入读1602状态模式
 
   EN_1602 = 1;//拉高使能信号
   sta = P2;   //将1602状态数据读取
   EN_1602 = 0;//拉低使能，完成读操作
 
   return sta; //将状态值返
}
```
图13-6 RD_sta()函数代码

a.  第1-3行为引脚定义，核心代码为第9-第16行；

b.  首先将RS拉低，表示要读取1602的状态，即第9行RS_1602 = 0;

c.  然后将R/W拉高，即 RW_1602 = 1;，接下来将使能信号E高，即 EN_1602 = 1;

d.  上面两条语句的时间间隔要求不低于t~SP1~，查询数据表格可知t~SP1~最小值为30ns，而我们开发板执行一条语句的时间大约为1us，因此远远能满足要求，如果我们在执行语句比较快的系统运行时，为了保证时序要求，可以在第10行和第12行两条语句之间插入软件延时。

e.  E的高电平维持时间t~PW~最小值为150ns，而我们E维持高电平约为1us，满足要求。t~D~最大值为100ns；

f.  因此，可以直接将DB0-DB7，即P2的数据读取，接着将E拉低完成状态读取，代码如第13-14行所示，最后第16行函数返回读取的数据sta。

时序要求，如下表所示：

表13-2 时序参数

![](../media/image142.png)  

### 13.2.2 单片机向1602写入一个字节

写操作时序与读操作的基本一致，唯一不同的是，在使能信号E拉高t~SP2~之前，单片机必须把需要写的数据送到数据端口上。当RS=1时，表示将要往1602写数据，当RS=0时，表示将要往1602里面写指令。

![](../media/image143.png)  

图13-7写操作时序

我们分别把写数据、写指令分别放到函数WR_Cmd(unsigned char cmd)、 WR_Dat(unsigned char dat)中。
```c
void WR_Cmd(unsigned char cmd)//写指令函数
{
    Ready();    //检测1602是否处于空闲状态
      
    RS_1602 = 0;
    RW_1602 = 0;//进入写指令模式
  
    P2 = cmd;   //将指令数据输出
  
   EN_1602 = 1;//拉高使能信号
   EN_1602 = 0;//拉低使能，完成写操作
}
void WR_Dat(unsigned char dat)//写数据函数
{
   Ready();    //检测1602是否处于空闲状态
 
   RS_1602 = 1;
   RW_1602 = 0;//进入写数据模式
 
   P2 = dat;   //将数据输出
 
   EN_1602 = 1;//拉高使能信号
   EN_1602 = 0;//拉低使能，完成写操作
}
```

图13-8 写指令函数代码

在上述函数中，增加了一个Ready()函数，这个函数的作用为查询1602是否处于空闲状态，当为空闲状态时，才开始写操作。到目前为止，我们已经完成了对1602最底层的数据读写操作，下面我们只要按照数据手册的要求调用这三个函数便可实现各种类型的显示功能。

对于1602而言，读状态函数RD_sta()，的返回值数据格式如下：

表13-3 状态字说明

![](../media/image144.png)  

如上表所示，返回状字的低六位为当前数据地址指针的数值，最高位读写操作使能，当返回值为1时，表示1602正处于忙的状态，不允许读写操作，当返回值为0时，表示可以对1602进行读写，因此，在读写前进行判断，我们将忙检测函数如下：
```c
void Ready() //空闲检测函数
{
    while(RD_sta() & 0x80);//bit7等于1表示忙，一直检测到0为止
}
```

图13-9 忙检测函数

## 13.3 1602液晶显示初始化

前面讲解的读取或写入1个字节是接下来所有操作的基础。在使用1602进行显示前，首先要通过写一系列的指令对1602进行初始化，各指令码及功能定义如下所示：

表13-4 指令码及功能定义

![](../media/image145.png)  ![](../media/image146.png)  

**初始化如下：**

1.  写指令38H：设置16x2显示，5x7点阵，8位数据接口；

2.  写指令0CH：开显示，关闭光标；

3.  写指令06H：读或写完一个字符后，地址指针、光标均加1；

4.  写指令01H：数据指针清零、所示显示清零

将初始化程序放到初始化函数Init_1602()中，代码如下图所示：
```c
void Init_1602() //1602初始化函
{
    WR_Cmd(0x38);//设置16x2显示，5x7点阵，8位数据接口
    WR_Cmd(0x0C);//开显示，关闭光标
    WR_Cmd(0x06);//读或写完一个字符后，地址指针、光标均加1
    WR_Cmd(0x01);//数据指针清零、所示显示清零
}
```

图13-10 初始化函数

## 13.4 1602液晶显示字符操作

当我们开始要往1602里面写字符的时候，我们首先得告诉1602我们要从哪个地方开始写，也就是写数据开始地址，1602共可以显示2行32个字符，那么每个字符的地址是多少呢？1602内部控制器有80字节的RAM缓冲区，RAM地址与1602显示模块的对应关系如下图所示：

![](../media/image147.png)  

图13-11 RAM地址映射图

如图所示，地址00H~0FH的RAM与显示模块的第一行一一对应。地址40H~4FH的 RAM与显示模块的第二行一一对应。这里要特别注意的是，第一行到第二行的地址不是连续的。通过写指令可以告诉1602我们将要从哪里开始写字符了，写地址指令码及功能定义如下表所示：

表13-5 地址指令码即功能定义

![](../media/image148.png)  

例如，需要往第二行的第一列开始写字符，首先应该写指令WR_Cmd(0x80 + 0x40)。接下通过调用写数据函数WR_Dat(dat)将对应的字符显示到1602了。写数据函数中的dat为字符对应的字符码，字符码可以通过查询1602的标准字符库，如下图所示，行坐标为字符码的低4位，纵坐标为字符码的高四位。例如，我们要将"C"显示到1602，需要调用WR_Dat(0x43)完成显示。

![](../media/image149.png)  

图13-12 标准1602字符字库

如上图所示，要显示一个字符需要每次都查表，显得特别的麻烦。如果我要显示C，可不可以直接WR_Dat('C')，来替代WR_Dat(0x43)，这样的话就非常容易理解了，答案是肯定，数字0-9，字母a-z，A-Z都可以这么表示，原因为你代码中'C'是以ASCII码存储在单片机中的，而这个ASCII码就是0x43，所以上面的两种写法是等价的。标准ASCII码对照表如下所示：

表13-6 标准ASCII码对照表

![](../media/image150.png)  

对照图13-11和表13-6常用的数字0-9，字母a-z，A-Z是一一对应的，这是1602液晶厂家为了应用方便而特意这么设计的。

根据上面的原理，我们可以设计一个这样的函数：功能为从第row行，第column列开始显示字符串str，函数代码如图所示：
```c
//字符串显示功能：从第row行，第column列开始显示字符串str
void Disp_1602_str(unsigned char row,unsigned char column,char *str)
{
    unsigned char addr;
  
    addr =  (row-1)*0x40 + (column-1);//组合成地址
    WR_Cmd(0x80+addr);//写地址命令
  
    while(*str)//判断str字符串是否已结束
   {
       WR_Dat(*str++);//将str字符串数据依次写入
   }
}
```

图13-13 字符串显示函数代码

后续，我们只需要调用这个函数便可以让1602显示数据了，我们将上述所有的函数定义放到Drive_1602.h文件中，函数具体实现均放到Drive_1602.c文件，这就是我们前面所讲的1602驱动文件，在工程中添加这两个文件就可以愉快的调用1602显示函数了。
```c
#ifndef __1602_H__  
#define __1602_H__  
  
//字符串显示函数声明
extern void Disp_1602_str(unsigned char row,unsigned char column,char *str);
extern void Init_1602();//1602初始化函数声明
  
void Ready();//空闲检测函数声明
void WR_Cmd(unsigned char cmd);//写指令函数声明
void WR_Dat(unsigned char dat);//写数据函数声明
unsigned char RD_sta();//读状态函数声明
 
#endif 
```

图13-14 Drive_1602.h文件
```c
#include<reg52.h>  
#include<Drive_1602.h>  
  
sbit RS_1602 = P3^6; //1602，RS、R/W，E引脚定义
sbit RW_1602 = P3^5;
sbit EN_1602 = P3^4;
  
//字符串显示功能：从第row行，第column列开始显示字符串str
void Disp_1602_str(unsigned char row,unsigned char column,char *str)
{
   unsigned char addr;
 
   addr =  (row-1)*0x40 + (column-1);//组合成地址
   WR_Cmd(0x80+addr);//写地址命令
 
   while(*str)//判断str字符串是否已结束
   {
       WR_Dat(*str++);//将str字符串数据依次写入
   }
}
 
void Init_1602() //1602初始化函
{
   WR_Cmd(0x38);//设置16x2显示，5x7点阵，8位数据接口
   WR_Cmd(0x0C);//开显示，关闭光标
   WR_Cmd(0x06);//读或写完一个字符后，地址指针、光标均加1
   WR_Cmd(0x01);//数据指针清零、所示显示清零
}
void Ready() //空闲检测函数
{
   while(RD_sta() & 0x80);//bit7等于1表示忙，一直检测到0为止
}
 
unsigned char RD_sta()//读状态函数
{
   unsigned char sta;
 
   RS_1602 = 0;
   RW_1602 = 1;//进入读1602状态模式
 
   EN_1602 = 1;//拉高使能信号
   sta = P2;   //将1602状态数据读取
   EN_1602 = 0;//拉低使能，完成读操作
 
   return sta; //将状态值返
}
void WR_Cmd(unsigned char cmd)//写指令函数
{
   Ready();    //检测1602是否处于空闲状态
     
   RS_1602 = 0;
   RW_1602 = 0;//进入写指令模式
 
   P2 = cmd;   //将指令数据输出
 
   EN_1602 = 1;//拉高使能信号
   EN_1602 = 0;//拉低使能，完成写操作
}
void WR_Dat(unsigned char dat)//写数据函数
{
   Ready();    //检测1602是否处于空闲状态
 
   RS_1602 = 1;
   RW_1602 = 0;//进入写数据模式
 
   P2 = dat;   //将数据输出
 
   EN_1602 = 1;//拉高使能信号
   EN_1602 = 0;//拉低使能，完成写操作
}
```

图13-15 Drive_1602.h文件

## 13.5 1602显示应用实例

我们结合上面讲解的各个函数，实现从1602液晶显示模块第1行第3列开始显示字符串"Nebula-Pi"。第二行第3列开始显示"LCD1602 Test!"，建立工程，编写MainLCD1602.c代码如下：
```c
/*******************************************************************
*  液晶LCD1602显示测试
* ******************************************************************
* 【主芯片】：STC89SC52/STC12C5A60S2
* 【主频率】: 11.0592MHz
*
* 【版  本】： V1.0
* 【作  者】： stephenhugh
* 【网  站】：https://rymcu.taobao.com/
* 【邮  箱】：
*
* 【版  权】All Rights Reserved
* 【声  明】此程序仅用于学习与参考，引用请注明版权和作者信息！
*
*******************************************************************/
#include<reg52.h>  
#include<Drive_1602.h>  
 
sbit DU = P0^6;//数码管段选定义
 
void main(void)
{
   P2 = 0x00;//关闭所有数码管
   DU = 1;
   DU = 0;//锁存段
     
   Init_1602();//1602初始化
     
   Disp_1602_str(1,3,"Nebula-Pi");//第1行第3列开始显示"RongYi Mini-51"
   Disp_1602_str(2,3,"LCD1602 Test!");//第2行第3列开始显示"LCD1602 Test!"
 
   while(1);
}
```

图13-16 LCD1602主程序代码

第17行包含了1602的驱动头文件，第23-25行先关闭所有数码管，因为数码管和1602共用P2，防止数码管乱跳显示。

安装好LCD1602硬件模块，并将程序下载单片机，扭动可变电阻R2调节LCD的对比度，效果如下图所示。

![](../media/image151.png)  

图13-17 LCD1602运行结果

## 13.6 本章小结

本章完成了液晶显示模块LCD1602的原理讲解，并且完成了驱动文件的编写，后续可以直接调用函数来显示数据了。
