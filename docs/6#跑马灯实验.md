#  第6章 跑马灯实验

## 6.1闪烁LED小灯

怎么让LED小灯闪烁？我们最先想到的办法当然是先让LED小灯点亮，延时一段时间，熄灭LED小灯，再延时一段时间，一直循环上面的步骤就能实现LED小灯的闪烁了。根据第3章的知识我们知道点亮LED的语句为"led0 = 0;",熄灭LED的语句为"led0 = 1;"。按照第3章介绍我们重新建立一个LED小灯闪烁的工程。编写LED.c，程序代码设计如下：

1.  /\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

2.  \*

3.  \* \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

4.  \* 【主芯片】：STC89SC52/STC12C5A60S2

5.  \* 【主频率】: 11.0592MHz

6.  \*

7.  \* 【版  本】： V1.0

8.  \* 【作  者】： hugh

9.  \* 【网  站】： https://rymcu.com

10. \* 【邮  箱】： hugh\@rymcu.com

11. \* 【店  铺】： rymcu.taobao.com

12. \*

13. \* 【版  权】All Rights Reserved

14. \* 【声  明】此程序仅用于学习与参考，引用请注明版权和作者信息！

15.           

16. \* 【功  能】闪烁LED

17. \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/

18. #include\<reg52.h> //寄存器声明头文件  

19. sbit led0 = P1\^0; // 位声明，将P1.0管脚声明为led0

20.   

21. **void** main()    //程序主函数入口，每个C语言程序有且只有一个

22. {

23.     **int** i;   //变量声明

24.     **while**(1) //循环

25.     {

26.         led0 = 0;    //赋值管脚P1.0为低电平，点亮LED小灯

27.         **for**(i=0;i\<5000;i++);//延时一段时间

28.   

29.         led0 = 1; //熄灭LED小灯

30.         **for**(i=0;i\<5000;i++);//再延时一段时间

31.     }

32. }

图6-1 闪烁LED代码

**代码解析：**

a)  第1行至第17行为注释，无需过多解释了；

b)  第18行替代了"sfr P1 = 0x90;"，稍后解释；

c)  第21,22,32行为主函数的固定写法；

d)  第24行是一个while()循环，里面表达式始终为真，所以程序将一直在while里面循环了；

e)  第26行，点亮LED0；

f)  第27行，for循环执行了5000次，而循环一次需要消耗一点时间，相当于延迟了一段时间,而这段时间内LED0一直点亮；

g)  第29行，熄灭LED0；

h)  第30行，继续延时一段时间

i)  回到第26行循环执行，因此，现象为LED0点亮一段时间，熄灭一段时间，循环往复，即LED闪烁功能了。

**第18行解析：**

"sfr P1 = 0x90;"这条语句被放到了reg52.h文件当中，我们只需要使用#include\<reg52.h>语句就可以把它添加到我们的程序中了。这么做的原因是，单片机有许多需要使用sfr定义的特殊功能寄存器，我们都像第三章那样，放在程序前面的话显得很冗长，keil很贴心的把所有定义都放到了reg52.h文件中，后缀名为.h的文件称为头文件。下面我们看看怎么查看头文件具体内容：

![](../media/image79.png)  

图6-2 如何打开查看.h头文件

按照2.3小节的方法，将程序编译下载至Nebula-Pi观察LED灯闪烁情况。

## 6.2跑马灯设计

在我们的开发板上设计了8个依次排列的LED小灯，让小灯依次点亮和熄灭实现跑马灯的效果是我们这一节的主要内容。

### 6.2.1硬件设计

8个LED小灯的硬件电路设计原理图如下图所示：

![](../media/image80.png)  

图6-3 8位跑马灯设计原理图

如上图所示，8个LED小灯D0\~D7的正极和电源VCC之间均串联了一个1K的限流电阻，LED小灯D7\~D0的负极与单片机的P1.7\~P1.0管脚一一相连。因此，在单片机程序中通过控制P1.7\~P1.0管脚的高低电平便可控制8个LED小灯的亮灭。

8位流水灯在开发的位置如下图所示：

![](../media/image81.png)  

图6-4 8个LED灯PCB布局图

该实验要实现的功能为：

首先点亮D0，然后延迟一段时间，熄灭D0点亮D1，延迟一段时间，熄灭D1点亮D2，延迟一段时间，一直到熄灭D6点亮D7，依照上面的步骤一直循环下去，便实现了一个简单的跑马灯的效果。

### 6.2.2软件设计

前面我们试验中都是只对P1.0这个管脚进行赋值，来控制LED小灯led0的亮灭。实际在编写程序的过程中我们可以对P1寄存器进行直接赋值来同时控制8个LED小灯。

表6-1 P1寄存器对照表

--------------------------------------------------------------------------------------------------------
功能       8位特殊功能寄存器                                                    P1赋值
---------- ------------------- ------ ------ ------ ------ ------ ------ ------ ------------- ----------
             P1.7                P1.6   P1.5   P1.4   P1.3   P1.2   P1.1   P1.0   二进制        十六进制

点亮LED0   1                   1      1      1      1      1      1      0      0b1111,1110   0xFE

点亮LED1   1                   1      1      1      1      1      0      1      0b1111,1101   0xFD

点亮LED2   1                   1      1      1      1      0      1      1      0b1111,1011   0xFB

点亮LED3   1                   1      1      1      0      1      1      1      0b1111,0111   0xF7

点亮LED4   1                   1      1      0      1      1      1      1      0b1110,1111   0xEF

点亮LED5   1                   1      0      1      1      1      1      1      0b1101,1111   0xDF

点亮LED6   1                   0      1      1      1      1      1      1      0b1011,1111   0xBF

点亮LED7   0                   1      1      1      1      1      1      1      0b0111,1111   0x7F
--------------------------------------------------------------------------------------------------------

如上表所示，P1寄存器是一个8位的寄存器，最高位到最低位依次对应的P1.7管脚到P1.0管脚。点亮某个LED小灯的二进制，十六进制赋值如上表所示。

例如：

P1 = 0xFE; 表示点亮led0

P1 = 0x7F; 表示点亮led7

在软件代码设计时，我们想到的第一个方法为依次点亮小灯并延时，代码如下图所示。

1.  /\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

2.  \*

3.  \* \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

4.  \* 【主芯片】：STC89SC52/STC12C5A60S2

5.  \* 【主频率】: 11.0592MHz

6.  \*

7.  \* 【版  本】： V1.0

8.  \* 【作  者】： hugh

9.  \* 【网  站】： https://rymcu.com

10. \* 【邮  箱】： hugh\@rymcu.com

11. \* 【店  铺】： rymcu.taobao.com

12. \*

13. \* 【版  权】All Rights Reserved

14. \* 【声  明】此程序仅用于学习与参考，引用请注明版权和作者信息！

15.           

16. \* 【功  能】闪烁LED

17. \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/

18. #include\<reg52.h> //加载头文件  

19.   

20. **int** i;

21.   

22. **void** main()//主函数入口

23. {

24.     P1 = 0xFE; //点亮LED0

25.     **for**(i=0;i\<5000;i++);//延时一段时间

26.     P1 = 0xFD; //点亮LED1

27.     **for**(i=0;i\<5000;i++);//延时一段时间

28.     P1 = 0xFB; //点亮LED2

29.     **for**(i=0;i\<5000;i++);//延时一段时间

30.     P1 = 0xF7; //点亮LED3

31.     **for**(i=0;i\<5000;i++);//延时一段时间

32.     P1 = 0xEF; //点亮LED4

33.     **for**(i=0;i\<5000;i++);//延时一段时间

34.     P1 = 0xDF; //点亮LED5

35.     **for**(i=0;i\<5000;i++);//延时一段时间

36.     P1 = 0xBF; //点亮LED6

37.     **for**(i=0;i\<5000;i++);//延时一段时间

38.     P1 = 0x7F; //点亮LED7

39.     **for**(i=0;i\<5000;i++);//延时一段时间

40. }

图6-5跑马灯代码

**代码解析：**

第24\~39行代码为从LED0\~LED7，依次点亮，并且每个之间延迟一段时间。按照，第三章的方法将程序下载至开发板，看看实际效果。

我们对代码进行一下小的改进，这个方法这里称之为"左移取反"法，这个方法在很多的应用中都能用到，非常实用，代码如图6-6所示。

1.  /\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

2.  \*

3.  \* \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

4.  \* 【主芯片】：STC89SC52/STC12C5A60S2

5.  \* 【主频率】: 11.0592MHz

6.  \*

7.  \* 【版  本】： V1.0

8.  \* 【作  者】： hugh

9.  \* 【网  站】： https://rymcu.com

10. \* 【邮  箱】： hugh\@rymcu.com

11. \* 【店  铺】： rymcu.taobao.com

12. \*

13. \* 【版  权】All Rights Reserved

14. \* 【声  明】此程序仅用于学习与参考，引用请注明版权和作者信息！

15.           

16. \* 【功  能】闪烁LED

17. \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/

18. #include\<reg52.h> //加载头文件  

19.   

20. **int** i;

21. **int** flag=0;

22.    

23. **void** main()//主函数入口

24.   

25. {

26.  P1 = 0xFF;//初始值，关闭所有LED灯

27.     **while**(1)

28.     {

29.      P1 = \~(0x01\<\<flag);//P1的值等于1左移flag位后取反，点亮第flag位LED小灯亮

30.         **for**(i=0;i\<25000;i++);//延时一段时间

31.   

32.         **if**(flag>=8)    //flag大于等于8时，置零，从零开始

33.         {

34.             flag=0;

35.         }

36.         **else**

37.         {

38.             flag++;  //flag累加

39.         }

40.     }

41.   

42. }

图6-6跑马灯代码改进

**代码解析：**

一整段代码的核心第19行的  P1 = \~(0x01 \<\< flag);

核心就是给 P1 这个有 8 位的寄存器赋予一个 8 位的值，使得 P1.0-P1.7 都有 1 或 0 的值。

\<\<：往左移位

> 0x01 = 0x0000 0001
>
> 0x01 \<\< 0 = 0x0000 0001
>
> 0x01 \<\< 1 = 0x0000 0010
>
> 0x01 \<\< 2 = 0x0000 0100

\~：取反，1-\>0或者0-\>1。

0x01 \<\< 0 = \~0x0000 0001 = 0x1111 1110 : P1.0=0，LED0亮

0x01 \<\< 1 = \~0x0000 0010 = 0x1111 1101 : P1.1=0，LED1亮

0x01 \<\< 2 = \~0x0000 0100 = 0x1111 1011 : P1.2=0，LED2亮

0x01 \<\< 7 = \~0x1000 0000 = 0x0111 1111 : P1.7=0，LED7亮

再分析第32-39行，flag每循环一次+1，当flag大于7时，被强制归0，因此，flag一直在0-7之间循环。因此，循环执行P1 = \~(0x01 \<\< flag);语句便实现了跑马灯的效果。赶快下载到开发板查看效果吧。

**小技巧：**

如果每次改进代码都需重新建工程，那就有点太繁琐了。我们只需要把当前的.c文件从工程移除，再添加新的.c文件，再编译即可。例如跑马灯原来的代码是led.c，改进的代码在LedNew.c文件中。切换的方法如下图所示：

![](../media/image82.png)  

图6-7 移除旧文件

![](../media/image83.png)  

图6-8 添加新文件

这里的移除，并不是直接删除.c文件，而是让它不参与工程的编译。如果要切换回来，同样用上述方法就可以了。

### 6.2.3下载验证

将程序通过STC-isp软件下载到单片机，观察8个LED小灯效果与设想的效果是否一致？至此，本章的内容讲解完毕，内容包括进制转换的基础知识、LED小灯闪速程序以及跑马灯的两种程序。大家在动手操作的过程中多多下载到单片机中观察现象，加深印象。

## 6.3本章小结

闪烁LED，跑马灯功能告一段落了。
